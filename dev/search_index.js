var documenterSearchIndex = {"docs":
[{"location":"Simulating/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"Simulating/#Defining-a-Phase","page":"Simulations","title":"Defining a Phase","text":"","category":"section"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"A phase in RMS defines how thermodynamic and kinetic parameters for individual species and reactions are calculated.  For the IdealGas case defining a phase is quite simple:  ","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"ig = IdealGas(spcs,rxns,name=\"gas\")","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"where spcs and rxns are lists of AbstractSpecies and AbstractReaction objects respectively.   For an IdealDiluteSolution it is slightly more complicated because some of these properties (currently  primarily diffusion limitations) can be dependent on the solvent:  ","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"solv = Solvent(\"octane\",RiedelViscosity(-98.805,3905.5,14.103,-2.5112e-5,2.0))\nliq = IdealDiluteSolution(spcs,rxns,solv;name=\"phase\",diffusionlimited=true)","category":"page"},{"location":"Simulating/#Defining-Initial-Conditions","page":"Simulations","title":"Defining Initial Conditions","text":"","category":"section"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"Initial conditions for the simulation are defined within a dictionary in SI units.  The keys \"T\",\"P\" and \"V\" correspond to thermodynamic values (\"V\" being the extensive volume) while species names correspond to numbers of moles (extensive).  ","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"For example, since the initial V can be calculated implicitly a valid IdealGas initial condition might be:  ","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"Dict([\"T\"=>1000.0,\"P\"=>1e5,\"H2\"=>0.67,\"O2\"=>0.33])","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"In the case of an IdealDiluteSolution where pressure is assumed to not affect the thermodynamic state it might look more like:  ","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"Dict([\"T\"=>450.0,\"V\"=>1.0e-6,\"octane\"=>6.154e-3,\"oxygen\"=>4.953e-6])","category":"page"},{"location":"Simulating/#Defining-an-Interface-object","page":"Simulations","title":"Defining an Interface object","text":"","category":"section"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"In many cases you will have connections between multiple domains in your system or between one domain and something outside the system. In these cases you need to define interfaces.","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"Example Inlet:","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"Flow(t::Float64) = 10.0\ninletdict= Dict([\"T\"=>800.0,\"P\"=>10.0e5,\"O2\"=>0.21, \"N2\"=>0.79])\ninlet = Inlet(domain,inletdict,Flow","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"Example Reactive Interface:","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"inter,pinter = ReactiveInternalInterfaceConstantTPhi(domainliq,domaincat,interfacerxns,Tinter,areainter)","category":"page"},{"location":"Simulating/#Defining-a-Domain","page":"Simulations","title":"Defining a Domain","text":"","category":"section"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"A domain in RMS is a homogeneous volume that contains a single phase.  The AbstractDomain object defines how the thermodynamics of the volume evolve with respect to time.  For example in a ConstantTPDomain the temperature and pressure are defined in the domain object and held constant over the simulation and the volume is integrated for while in a ConstantVDomain (a constant V adiabatic reactor) the volume is kept constant and the temperature is integrated for.","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"When constructing a Domain object constant concentration species can be defined (list of species names).   During integration the derivatives with respect to time of these species will be kept at zero.  ","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"IdealDiluteSolution example:  ","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"domain,y0,p = ConstantTVDomain(phase=liq,initialconds=initialconds,constantspecies=[\"oxygen\"])","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"IdealGas example:  ","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"domain,y0,p = ConstantTPDomain(phase=ig,initialconds=initialconds)","category":"page"},{"location":"Simulating/#Defining-a-Reactor-object","page":"Simulations","title":"Defining a Reactor object","text":"","category":"section"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"The Reactor object exists primarily to automatically sets up the ODEProblem object for you to solve.   For single domain reactors it takes the domain, the initial condition vector returned when constructing the domain, a time interval and an array of any interface objects and returns a Reactor object. If your system has multiple domains you need to pass the domains, initialconditions time interval, array of interfaces and parameters with the domains, associated initial conditions and associated parameters as tuples in consistent order from domains to interfaces.","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"Example single domain:  ","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"react = Reactor(domain,y0,(0.0,150.1),interfaces,p=p)","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"Example multiple domains:","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"react,y0,p = Reactor((domainliq,domaincat), (y0liq,y0cat), (0.0, 1.0e5), [inter], (pliq,pcat,pinter))","category":"page"},{"location":"Simulating/#Solving-a-Reactor-object","page":"Simulations","title":"Solving a Reactor object","text":"","category":"section"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"RMS purposefully exposes the solver interface provide users with all the options available from Julia's DifferentialEquations package.  The ODEProblem object is a field of the Reactor object react.ode and can be solved as the user desires. A recommended solver choice is stored in react.recommendedsolver. User can also specify their own choice of solver.","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"Forward sensitivity analysis can also be requested on the Reactor object by setting forwardsensitivities=true. Note that adjoint and threaded sensitivity analyses are usually much faster. Adjoint sensitivity analysis can be done as postprocessing analysis after the simulation is complete without a need to set forwardsensitivities=true during the simulation (this are discussed in the Analysis section). Threaded sensitivity analysis will be discussed in the next section.","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"Example:","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"sol = solve(react.ode,react.recommendedsolver,abstol=1e-20,reltol=1e-12)","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"sol = solve(react.ode,CVODE_BDF(),abstol=1e-20,reltol=1e-12;forwardsensitivities=true)","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"In general CVODE_BDF tends to work well on these problems.  ","category":"page"},{"location":"Simulating/#Threaded-Sensitivity-Analysis","page":"Simulations","title":"Threaded Sensitivity Analysis","text":"","category":"section"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"Instead of solving all of the sensitivity equations at once as is done in raw Forward sensitivity analysis we can first solve the equations without sensitivity analysis alone. With an interpolatable solution to the original equations the sensitivities associated with each parameter are decoupled from the sensitivities of every other parameter and can be solved independently. Solving these groups of equations sequentially is often significantly faster than solving the equations together. However, by parallelizing the solution of these equations using multithreading it is possible to achieve dramatic speed ups. This approach is not always competitive with adjoint sensitivities as the adjoint approach requires solution of a much smaller system of equations, however, in practice this approach is often more robust especially for large systems.","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"In order to take advantage of multithreading you must set the number of threads before launching Julia see the documentation <a href=\"https://docs.julialang.org/en/v1/manual/multi-threading/\">here</a>. We provide two methods for this algorithm. The first method below calculates the sensitivities of all variables to all parameters and provides a solution object that can be used in the same way as the output of a solve on a Reactor with forwardsensitivities=true:","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"using Base.Threads\nnthreads = Threads.nthreads()\nprintln(\"Using $nthreads threads\")\n\nsol = threadedsensitivities(react; odesolver=react.recommendedsolver,senssolver=react.recommendedsolver,\n        odekwargs=Dict([:abstol=>1e-20,:reltol=>1e-6]),senskwargs=Dict([:abstol=>1e-6,:reltol=>1e-3]))","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"We also provide a second method shown below. This variant allows the user to specify the indices of the parameters to calculate sensitivities for. However, because not all of the sensitivies are calculated the results cannot be formatted into a solution object that can be fed into a Simulation or SystemSimulation object. So instead a dictionary mapping the parameter index to an ODE solution of the associated sensitivity equations is provided. Note  that parameters are structured starting in species order with parameters corresponding to the Gibbs free energy of each species and continuing in reaction order with a parameter corresponding to each rate coefficient. The output solution objects are in species + thermodynamic variable order and are the raw sensitivities with no normalization.","category":"page"},{"location":"Simulating/","page":"Simulations","title":"Simulations","text":"using Base.Threads\nnthreads = Threads.nthreads()\nprintln(\"Using $nthreads threads\")\n\nsoldict = threadedsensitivities(react,indices; odesolver=react.recommendedsolver,senssolver=react.recommendedsolver,\n        odekwargs=Dict([:abstol=>1e-20,:reltol=>1e-6]),senskwargs=Dict([:abstol=>1e-6,:reltol=>1e-3]))","category":"page"},{"location":"Input/#Input","page":"Input","title":"Input","text":"","category":"section"},{"location":"Input/#Accepted-file-formats","page":"Input","title":"Accepted file formats","text":"","category":"section"},{"location":"Input/","page":"Input","title":"Input","text":"RMS currently supports its own .rms YAML based file format and Chemkin (.inp) format files (if an RMG species_dictionary.txt file is available it can be taken along with the Chemkin file to provide molecular structure information for the Chemkin file   species).  Chemkin files can be in any units and individual units (quantities specified in Unitful format:  1.0u\"m^3\") are accepted with the RMS format files.  These can be loaded","category":"page"},{"location":"Input/","page":"Input","title":"Input","text":"phaseDict = readinput(\"../src/testing/mech.rms\")","category":"page"},{"location":"Input/","page":"Input","title":"Input","text":"or","category":"page"},{"location":"Input/","page":"Input","title":"Input","text":"phaseDict = readinput(\"chem_annotated.inp\";\n              spcdict=\"species_dictionary.txt\")","category":"page"},{"location":"Input/","page":"Input","title":"Input","text":"respectively.  Note that spcdict is an optional parameter.  ","category":"page"},{"location":"Input/#Output-of-Input-File-Reading","page":"Input","title":"Output of Input File Reading","text":"","category":"section"},{"location":"Input/","page":"Input","title":"Input","text":"The output of reading an input file in RMS returns a dictionary of phase dictionaries indexed by the name of each phase. Each phase dictionary has an array of Species objects corresponding to the key \"Species\" and an array of Reaction Objects corresponding to the key \"Reactions\".","category":"page"},{"location":"Input/#YAML-File-Formats","page":"Input","title":"YAML File Formats","text":"","category":"section"},{"location":"Input/","page":"Input","title":"Input","text":"RMS uses a YAML format input file.  YAML essentially stores information in embedded dictionaries and lists. An example segment from a .rms file is given below.  ","category":"page"},{"location":"Input/","page":"Input","title":"Input","text":"Phases:\n- Species:\n  - name: Ar\n    smiles: '[Ar]'\n    thermo:\n      polys:\n      - Tmax: 3459.6\n        Tmin: 100.0\n        coefs: [2.5, 9.24384602e-15, -1.36779837e-17, 6.66184769e-21, -1.00106912e-24,\n          -1552.16105, 2.16745116]\n        type: NASApolynomial\n      - Tmax: 5000.0\n        Tmin: 3459.6\n        coefs: [2.49999999, 9.20455546e-12, -3.58608293e-15, 6.15198922e-19, -3.92041801e-23,\n          -1552.16104, 2.16745122]\n        type: NASApolynomial\n      type: NASA\n    type: Species\n  - name: He\n    smiles: '[He]'\n    thermo:\n      polys:\n      - Tmax: 3459.6\n        Tmin: 100.0\n        coefs: [2.5, 9.24384602e-15, -1.36779837e-17, 6.66184769e-21, -1.00106912e-24,\n          -1552.16105, -1.28349484]\n        type: NASApolynomial\n      - Tmax: 5000.0\n        Tmin: 3459.6\n        coefs: [2.49999999, 9.20455546e-12, -3.58608293e-15, 6.15198922e-19, -3.92041801e-23,\n          -1552.16104, -1.28349478]\n        type: NASApolynomial\n      type: NASA\n  name: phase\n  Reactions:\n  - kinetics: {A: 2.7590590000000007e-08, Ea: 26459.615999999998, n: 3.802, type: Arrhenius}\n    products: [oxygen, octane]\n    reactants: ['C[CH]CCCCCC', '[O]O']\n    type: ElementaryReaction\n  - kinetics: {A: 2.7590590000000007e-08, Ea: 26459.615999999998, n: 3.802, type: Arrhenius}\n    products: [oxygen, octane]\n    reactants: ['CCC[CH]CCCC', '[O]O']\n    type: ElementaryReaction","category":"page"},{"location":"Input/","page":"Input","title":"Input","text":"Dashes - denote the beginning of a new key:value pair.  If done in series as above under Species: and under Reactions: this makes an array of dictionaries.  Colons : denote the beginning of a key:value pair within a dictionary.  Key, value pairs following a dash that do not have a dash themselves are part of the same dictionary.  You can also define dictionaries and lists as normal within Julia within the YAML.  ","category":"page"},{"location":"Input/#.rms-File-Format","page":"Input","title":".rms File Format","text":"","category":"section"},{"location":"Input/","page":"Input","title":"Input","text":"In YAML RMS amounts to a dictionary of phase dictionaries.  Each phase dictionary has an entry corresponding to \"Species\", \"Reactions\" and \"name\".  The \"name\" corresponds to the name of the phase.  Within \"Species\" and \"Reactions\" are associated lists of dictionaries that correspond to Species and Reaction objects.  Beneath \"Species\" and \"Reactions\" the structures all follow the same conventions.  ","category":"page"},{"location":"Input/","page":"Input","title":"Input","text":"Each dictionary is assumed to correspond to an object within RMS that should be denoted by the type key and to have key:value maps that correspond to all necessary parameters to construct the object corresponding to the type value.  Thus, the an Arrhenius rate calculator can be defined as {A: 2.7590590000000007e-08, Ea: 26459.615999999998, n: 3.802, type: Arrhenius}.  In that case RMS knows the object from the type value and what to put in the Arrhenius object from the remaining fields.  Of course for more complex objects some of the values will correspond to objects themselves and thus be dictionaries with their own type values.  ","category":"page"},{"location":"Input/","page":"Input","title":"Input","text":"Units can be defined for specific numerical values in the Unitful format 1.0u\"m^3.  However, currently molecular units are not supported and thus moles must be used (this restriction applies only to .rms files and not to Chemkin format files).  ","category":"page"},{"location":"Analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"Analysis/#The-Simulation-Object","page":"Analysis","title":"The Simulation Object","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"Since the solver interface is exposed the solution object generated only gives the raw moles and raw sensitivity values, which typically are not what a user wants.  The Simulation object combines the solution information and the domain information to calculate much more useful properties of the solution.  ","category":"page"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"The Simulation object can be defined:  ","category":"page"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"bsol = Simulation(sol,domain,interfaces,p)","category":"page"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"where sol is the ODESolution object output by the DifferentialEquations package, domain is the domain sol corresponds to, interfaces is the array of interface objects and p is the parameter vector.","category":"page"},{"location":"Analysis/#The-SystemSimulation-Object","page":"Analysis","title":"The SystemSimulation Object","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"When a system involves multiple domains a single Simulation object is insufficient. For these systems you need to construct a SystemSimulation object. This works in much the same way except that the domains should be listed as a tuple and the domain and interface ordering should be the same as that used when constructing the Reactor object. In theory the SystemSimulation object should be able to be used in place of a Simulation object in most places (If this is not the case and should be the case please make an issue!).","category":"page"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"ssys = SystemSimulation(sol,(domainliq,domaincat,),interfaces,p);","category":"page"},{"location":"Analysis/#Useful-Properties","page":"Analysis","title":"Useful Properties","text":"","category":"section"},{"location":"Analysis/#Thermodynamic-Properties","page":"Analysis","title":"Thermodynamic Properties","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"Any thermodynamic property (T,P,V,C) at any given time t can be calculated in the format","category":"page"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"getT(bsol,t)","category":"page"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"where T can be replaced by any of the other properties.  ","category":"page"},{"location":"Analysis/#Mole-Fractions","page":"Analysis","title":"Mole Fractions","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"Mole fraction information can be retrieved using the molefraction function.   molefraction(bsol) will give the mole fractions of all species at the times bsol.sol.t.   molefraction(bsol,t) will the mole fractions of all species at time t.   molefraction(bsol,name,t) will give the mole fraction of the species with name name at time t.  ","category":"page"},{"location":"Analysis/#ROPs","page":"Analysis","title":"ROPs","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"Rates of production/consumption (associated with each reaction and each species at a given time) can be retrived using the rops function.   rops(bsol,t) will the matrix of rops for all species and all reactions at time t.   rops(bsol,name,t) will give the array of rops for the species with name name at time t.  ","category":"page"},{"location":"Analysis/#Concentration-Sensitivities","page":"Analysis","title":"Concentration Sensitivities","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"Concentration sensitivities to rate coefficients and species gibbs free energies can be retrieved using the getconcentrationsensitivity(bsol,numerator,denominator,t) function.   Here bsol denotes the Simulation object, and t denotes the time.  The output is the sensitivity of the numerator to the denominator.  For species concentration and species thermo this is the name of the species for reactions this is the index of the reaction.  ","category":"page"},{"location":"Analysis/#Rates","page":"Analysis","title":"Rates","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"The function rates can be used to calculate the rates of all reactions at specific time points.   rates(bsol,t) will give the array of reaction rates at time t while rates(bsol;ts=ts) will give a matrix of reaction rates at all times in ts.   Note that ts defaults to bsol.sol.t.  ","category":"page"},{"location":"Analysis/#Adjoint-Sensitivities","page":"Analysis","title":"Adjoint Sensitivities","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"Sensitivity values to a target species or thermodynamic variable can be computed from a Simulation or SystemSimulation object using the getadjointsensitivities(bsol::Q,target::String,solver::W;sensalg::W2=InterpolatingAdjoint(autojacvec=ReverseDiffVJP(false)),abstol::Float64=1e-6,reltol::Float64=1e-3,normalize=true,kwargs...) function. This computes the sensitivity with respect to the target at the final time point of bsol. It uses solver, sensalg, abstol, and reltol for the adjoint solve and by default will give the normalized sensitivity values (note these are molar sensitivities, concentration sensitivities can't be computed from a single adjoint pass). This is usually much faster than forward sensitivities.","category":"page"},{"location":"Analysis/#Transitory-Sensitivities","page":"Analysis","title":"Transitory Sensitivities","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"Transitory sensitivity values can be computed using several different algorithms. transitorysensitivitiesfullexact(sim::Simulation,t;tau=NaN,         normalized=true,solver=Sundials.CVODE_BDF(linear_solver=:GMRES),         abstol=1e-16,reltol=1e-6) gives you the exact full matrix of transitory sensitivities using the forward sensitivity algorithm, while transitorysensitivitiesfulltrapezoidal(sim,t;tau=NaN,normalized=true) gives the approximate full matrix of transitory sensitivities using the trapezoidal method. transitorysensitivitiesparamexact and transitorysensitivitiesparamtrapezoidal are available for computing a single column of the matrix (with respect to a single parameter)). Lastly transitorysensitivitiesadjointexact(sim::Simulation,t,name;tau=NaN,         normalized=true,solver=Sundials.CVODE_BDF(),sensalg=InterpolatingAdjoint(),         abstol=1e-16,reltol=1e-6) is available for computing a single row of the matrix (sensitivity to a specified species with respect to all parameters). The adjoint algorithm is jacobian free if tau is specified and the solver is jacobian free. ","category":"page"},{"location":"Analysis/#Other-Useful-Properties","page":"Analysis","title":"Other Useful Properties","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"Please let us know on our Github issues page if we're missing any important property calculators.  ","category":"page"},{"location":"Analysis/#Plotting","page":"Analysis","title":"Plotting","text":"","category":"section"},{"location":"Analysis/#Plotting-Mole-Fractions","page":"Analysis","title":"Plotting Mole Fractions","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"Mole fractions can be plotting using the plotmolefractions function plotmolefractions(bsol, tf; t0=1e-15,N=1000,tol=0.01) plots all species with molefraction greater than tol at N logarithmically spaced time points between t0 and tf.   plotmolefractions(bsol; tol=0.01) plots all species with molefraction greater than tol at the points in bsol.sol.t.   plotmolefractions(bsol,spcnames) plots all the species with names in spcnames at the points in bsol.sol.t.  ","category":"page"},{"location":"Analysis/#Plotting-Forward-Sensitivities","page":"Analysis","title":"Plotting Forward Sensitivities","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"Sensitivities (normalized molar sensitivities) can be plotted using the plotmaxthermoforwardsensitivity and plotmaxrateforwardsensitivity functions.   Both of these follow the same format:   plotmaxthermoforwardsensitivity(bsol, spcname; N=0, tol= 1e-2) spcname corresponds to the species sensitivities are being calculated for, N is the maximum number of sensitive species/reactions plotted (0 corresponds to all of them), sensitive species/reactions with sensitivities less than tol are not included in the plot.  Note that the thermo sensitivities are given in mol/kcal while the rate sensitivities are fully non-dimensionalized (as displayed on the plots).  ","category":"page"},{"location":"Analysis/#Plotting-Adjoint-Sensitivities","page":"Analysis","title":"Plotting Adjoint Sensitivities","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"Adjoint sensitivities can be plotted using the plotthermoadjointsensitivities(bsol::Y,name::X,dps::Z;N=0,tol=0.01) and plotrateadjointsensitivities(bsol::Y,name::X,dps::Z;N=0,tol=0.01) functions where dps is the normalized adjoint sensitivity values.","category":"page"},{"location":"Analysis/#Plotting-ROPs","page":"Analysis","title":"Plotting ROPs","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"ROPs can be plotted with the plotrops function.   plotrops(bsol,name,t;N=0,tol=0.01) will plot the ROPs for species with name name at time t including at most N reactions and not including reactions with absolute rates less than tol * the largest absolute rate.  This is a bar plot comparing the reactions that contribute the most to the production and loss of the species","category":"page"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"The rops can be plotted with respect to time on a line plot using plotrops(bsol,name;rxnrates=Array{Float64,1}(),ts=Array{Float64,1}(),tol=0.05) in this case rxnrates corresponds to the matrix of reaction rates at each time point (can be expensive to compute so if available can be reused), ts correpsonds to a set of time points to plot at (otherwise defaults to bsol.sol.t), any reaction with flux smaller than tol * the largest absolute rate at every time point is excluded from the plot.  ","category":"page"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"The analogous functions plotradicalrops(bsol,t;N=0,tol=0.01) and plotradicalrops(bsol;rxnrates=Array{Float64,1}(),ts=Array{Float64,1}(),tol=0.05) are available for plotting the rops for the sum of all radicals.","category":"page"},{"location":"Analysis/#Plotting-Transitory-Sensitivities","page":"Analysis","title":"Plotting Transitory Sensitivities","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"Transitory sensitivities and be combusted and plotted using plotrxntransitorysensitivities(bsol,name,t;dSdt=nothing,tau=nothing,tol=1e-3,N=0,rxntol=1e-6) and plotthermotransitorysensitivities(bsol,name,t;dSdt=nothing,tau=nothing,tol=1e-3,N=0) where dSdt contains the transitory sensitivity values otherwise these values will be computed automatically using the trapezoidal method using the input tau or automatically selecting tau and the rxntol value. At most N reactions are included in the plot and the plot will not include reactions with absolute transitory sensitivities less than tol times the largest absolute value.","category":"page"},{"location":"Analysis/#Plotting-Time-Scales","page":"Analysis","title":"Plotting Time Scales","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"The timescale distribution of a simulation at a point can be plotted using plottimescales(sim,t;taumax=1e6,taumin=1e-18,taures=10.0^0.5,usediag=true) or plottimescales(Jy;taumax=1e6,taumin=1e-18,taures=10.0^0.5,usediag=true) where taumax, taumin and taures control the bins. If usediag=true it will simply determine the timescales using the diagonal of the Jacobian otherwise it will compute and use the eigenvalues. In general we've observed no significant differences in distributions generated using the diagonal values vs the eigenvalues although there may be significant differences when the mechanism is small.","category":"page"},{"location":"Analysis/#Other-Plots","page":"Analysis","title":"Other Plots","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"While we are trying to build up a library of plotting functions that make mechanism analysis easier we may not have the one you need.  However, the tools in the Useful Properties section should be enough most of the time. We're happy to provide guidance on our Github issues page and add plotting functions you find useful.  ","category":"page"},{"location":"Analysis/#Flux-Diagrams","page":"Analysis","title":"Flux Diagrams","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"RMS generates flux diagrams with molecular images (or names when images aren't available) using the getfluxdiagram function:  ","category":"page"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"getfluxdiagram(bsol,t;centralspecieslist=Array{String,1}(),superimpose=false,\n    maximumnodecount=50, maximumedgecount=50, concentrationtol=1e-6, speciesratetolerance=1e-6,\n    maximumnodepenwidth=10.0,maximumedgepenwidth=10.0,radius=1,centralreactioncount=-1,outputdirectory=\"fluxdiagrams\")","category":"page"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"This generates a flux diagram at the time point t.  centralspecieslist denotes a list of species that must be included in the diagram, maximumnodecount denotes the maximum number of species in the diagram, maximumedgecount denotes the maximum number of connections between species, concentrationtol denotes the lowest fractional concentration to show in the diagram, speciesratetolerance denotes the lowest fraction species rate to show in the diagram, maximumNodePenWidth denotes the thickness of the border around a node a maximum concentration.  maximumedgepenwidth denotes the thickness of the edge at maximum species rate, radius is the graph radius plotted around a central species.  ","category":"page"},{"location":"Analysis/#Other-Useful-Functionality","page":"Analysis","title":"Other Useful Functionality","text":"","category":"section"},{"location":"Analysis/","page":"Analysis","title":"Analysis","text":"spcindex(bsol,name) will give you the index of the species with name name.  ","category":"page"},{"location":"#RMS-Reaction-Mechanism-Simulator","page":"Home","title":"RMS - Reaction Mechanism Simulator","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RMS is a Julia package designed for simulating and analyzing large chemical reaction mechanisms.  ","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ideal gas, dilute liquid and ideal surface phases.  \nMany different reaction domains (ConstantTP, ConstantV, ConstantTV, ParametrizedTPDomain, and many more.\nDiffusion limited rates.\nForward and Adjoint Sensitivity analysis.\nFlux diagrams with molecular images (if molecular information is provided).  \nHandy plotting and other solution analysis tools.  \nAutomatic mechanism analysis toolkit.\nEasy to add new features.  ","category":"page"},{"location":"AutomaticMechanismAnalysis/#Automatic-Mechanism-Analysis","page":"Automatic Mechanism Analysis","title":"Automatic Mechanism Analysis","text":"","category":"section"},{"location":"AutomaticMechanismAnalysis/#Running-Automatic-Mechanism-Analysis","page":"Automatic Mechanism Analysis","title":"Running Automatic Mechanism Analysis","text":"","category":"section"},{"location":"AutomaticMechanismAnalysis/","page":"Automatic Mechanism Analysis","title":"Automatic Mechanism Analysis","text":"Automatic mechanism analysis can be run for a single species at a single time point using the function analyzespc(sim,spcname,t;N=10,tol=1e-3,branchthreshold=0.9,         pathbranchthreshold=0.2,branchtol=1e-2,steptol=1e-2,         transitorysensitivitymethod=transitorysensitivitiesfulltrapezoidal,         eliminate=true         ). This returns an array of ReactionAnalysis objects corresponding to each reaction found in the analysis (based on N and tol choices).","category":"page"},{"location":"AutomaticMechanismAnalysis/#ReactionAnalysis-Object","page":"Automatic Mechanism Analysis","title":"ReactionAnalysis Object","text":"","category":"section"},{"location":"AutomaticMechanismAnalysis/","page":"Automatic Mechanism Analysis","title":"Automatic Mechanism Analysis","text":"The ReactionAnalysis object has seven attributes, branchings the array of potentially important Branching objects, paths the array of potentially important ReactionPath objects, radprodlossfract the fraction of production (+) or loss (-) of radicals that this reaction accounts for, spcind the index of the target species, spcname the name of the target species, rxnind the index of the reaction and sens the transitory sensitivity value. Can be dumpped to a string report by getrxnanalysisstring(sim,ra;branchingcutoff=1e-2,radbranchfract=0.01) or simply printed with printrxnanalysis(sim,ra;branchingcutoff=1e-2,radbranchfract=0.01) where the branchingcutoff is the fraction of the branching at which reactions will no longer show up as part of a branching and radbranchfract is the fraction of radical production/loss above which the value is displayed as important.","category":"page"},{"location":"AutomaticMechanismAnalysis/#Branching-Object","page":"Automatic Mechanism Analysis","title":"Branching Object","text":"","category":"section"},{"location":"AutomaticMechanismAnalysis/","page":"Automatic Mechanism Analysis","title":"Automatic Mechanism Analysis","text":"The Branching object has three attributes, spcind the index of the target species, rxninds the array of the indices of the reactions in order of branching fraction, branchingratios the fraction of the branching accounted for by each reaction. Can be used to generate a flux diagram with getfluxdiagram(bsol,t,b::Branching; branchtol=1.0e-2, kwargs...) where branchtol is the fraction of the branching at which the product of a reaction will not be included in the flux diagram. Note this flux diagram includes all reaction between species part of the important branching reactions and not just the branching reactions themselves.","category":"page"},{"location":"AutomaticMechanismAnalysis/#ReactionPath-Object","page":"Automatic Mechanism Analysis","title":"ReactionPath Object","text":"","category":"section"},{"location":"AutomaticMechanismAnalysis/","page":"Automatic Mechanism Analysis","title":"Automatic Mechanism Analysis","text":"The ReactionPath object has six important attributes, forward indices whether the path was generated following the flux forward from the target species or backwards from the target species, spcsinds is the array of the species indices followed in order along the flux path, rxninds is the array of reactions that connect these spcsinds, spcind is the index of the target species, branchfracts is the branching fraction of the reaction in rxninds for the species in spcsinds, branchfract is the fraction of the flux following from the start of the path to the end. Can be used to generate a flux diagram with getfluxdiagram(bsol,t,rp::ReactionPath; radius=0, kwargs...). Note this flux diagram includes all reactions between species that are parts of the ReactionPath and not just the reaction path itself. ","category":"page"}]
}
